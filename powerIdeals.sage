
from sage.graphs.independent_sets import IndependentSets
from collections import OrderedDict
import string
allLetters=string.lowercase
from sage.matroids.advanced import *

def transM(sys):
    # receives a collection of r subsets of a ground set
    # generates the corresponding transversal matroid
    # also gives a representation matrix
    r = len(sys)
    edges = []
    for i in range(r):
        for j in sys[i]:
            e=('0'+allLetters[i],'1'+allLetters[j])
            edges.append(e)

            
    bG = Graph(edges)

    n = len(bG.vertices())-r
        
    adj = bG.adjacency_matrix()[0:r, r:n+r]
    
    lG = bG.line_graph(labels=False)

    Brep =sorted([sorted([allLetters.index(p[1][1:]) for p in m]) for m in IndependentSets(lG) if len(m)==r])

    M=Matroid(bases=Brep)

    while True:
        t=[]    
        while True:
            #q=ZZ.random_element(-7,7)
            q=QQ.random_element(11,11)
            if q != 0 and q not in t: t.append(q)
            if len(t)==n: break
        # t.sort()  # use this for `random points` along moment curve
        
        t=range(1,n+1) # use this for evenly separated points along moment curve
        
        repMat =  Matrix([[adj[i,j]*t[j]^(i+1) for j in range(n)] for i in range(r)])
        mA=Matroid(repMat)
        if M.equals(mA)==True: break
    
    
    return repMat

def parkIt(A):

    # takes as input a matrix repMat 

    # first find the lines in the arrangement defined by repMat.

    # then compute their product with the columns of the matrix

    # in the resulting matrix, track in each entry of every row, which coordinates
    # of the corresponding line contribute to the support

    M = Matroid(A)

    rk = M.rank()
    num = len(M.groundset())

    lines=[]
    
    for h in M.hyperplanes():

        # Ah contains the columns of A labelled by elements in hyperplane h
        Ah = Matrix([[A[i,j] for j in list(h)] for i in range(rk)])


        line = list(Ah.kernel().basis()[0])
        lines.append(line)

    linesMatrix=Matrix(lines)

    # the supports of the rows of this matrix should correspond to the cocircuits
    # of the matroid of A
    cMatrix=linesMatrix*A
    
    return [linesMatrix, cMatrix]

def graphPS(g):
    # this receives a graph g and generates m2 code for the
    # Postnikov-Shapiro monomial ideal, generated by subsets of
    # vertices corresponding to cocircuits (a.k.a. cuts)

    M = Matroid(g)
    
    E = g.edges(labels=None)
    
    V = g.vertices()
    
    Vp = V[1:len(V)]
    
    S = [s for s in Subsets(Vp) if s.is_empty()==False]

    degs = [[len(g.edge_boundary([f],Set(V).difference(J), labels=False)) for f in J] for J in S]

        # check this below:
    Shype = [s for s in S if (Graph(g.subgraph(Set(V).difference(s))).is_connected() and Graph(g.subgraph(s)).is_connected())==True ]
    
    dHype = [[len(g.edge_boundary([f],Set(V).difference(J), labels=False)) for f in J] for J in Shype]

    # I2 is the ideal generated by monomials corresponding to cocircuits
    gensI2 = 'ideal('+', '.join(['*'.join(['x'+str(Shype[i][j])+'^'+str(dHype[i][j])  for j in range(len(Shype[i])) ]) for i in range(len(Shype))])+')'
    ## J2 is the ideal generated by powers of linear forms corresponding to cocircuits
    #gensJ2 = 'ideal('+', '.join(['('+'+'.join(['x'+str(j) for j in list(Shype[i])])+')^'+str(sum(dHype[i])) for i in range(len(Shype))])+')'

    #return [gensI2, Shype]
    return gensI2

def graphArrgt(g):
    # receives a graph g and writes the Postnikov-Shapiro
    # matrix representing the associated graphic arrangement
    # A_{i,e}=1 if e=(i,j), i<j; -1 if e=(i,j), i>j; 0 else

    A=[[1 if v==e[0] else -1 if v==e[1] else 0 for e in g.edges(labels=False)] for v in g.vertices()]

    Ag=Matrix(A[1:])

    return Ag
    

def pIdeal(A):
    # given a d\times n matrix representing a matroid M
    # writes the generators of the power ideal of its
    # associated hyperplane arrangement. variable indexes
    # start at 1

    n=len(A.columns())

    M=Matroid(A)

    #V = [repMat[:,list(h)].kernel().basis()[0] for h in M.hyperplanes()]
    
    H = 'ideal('+', '.join(['('+'+'.join([str(A[:,list(h)].kernel().basis()[0][i])+'*x_'+str(i+1) for i in range(len(A[:,list(h)].kernel().basis()[0])) if A[:,list(h)].kernel().basis()[0][i] != 0])+')^'+str(n-len(h)) for h in M.hyperplanes()])+')'

    return H

#def Parking(A,g):
def Parking(A):
# receives a full rank d\times n matrix representing a matroid
# writes code for its power ideal and some properties like
# betti table, hilbert series
# builds associated transversal matroid by substituting nonzero
# entries "generically", and writes code for its power ideal etc.

# the input g should only come when A is representation of graph g

    M=Matroid(A)
    rk=len(A.rows()) 
    num=len(A.columns())

    # use the following only if A represents transversal matroid
    setSystem='-'.join([''.join([str(i) for i in range(len(r)) if r[i]!=0]) for r in A.rows()])
    
    

    #### -- this pertains to original matroid #####################       
            
    Am2='A=matrix{'+ ', '.join(['{'+', '.join([str(A[i,j]) for j in range(num)])+'}\n' for i in range(rk)])+'}'

    [L,C]=parkIt(A)

    Lm2='L=matrix{'+ ', '.join(['{'+', '.join([str(L[i,j]) for j in range(len(L.columns()))])+'}\n' for i in range(len(L.rows()))])+'}'
    Cm2='C=matrix{'+ ', '.join(['{'+', '.join([str(C[i,j]) for j in range(len(C.columns()))])+'}\n' for i in range(len(C.rows()))])+'}'
        
    CoC=str([list(set(M.groundset())-set(h)) for h in M.hyperplanes()])

    pI='I='+pIdeal(A)

    #### -- this pertains to relaxed matroid #####################

    #setSystem=[[i for i in range(len(r)) if r[i]!=0] for r in A.rows()]
    #relaxA=transM(setSystem)
    #relaxM=Matroid(relaxA)

    #relAm2='relA=matrix{'+ ', '.join(['{'+', '.join([str(relaxA[i,j]) for j in range(num)])+'}\n' for i in range(rk)])+'}'

    #[relL,relC]=parkIt(relaxA)

    #relLm2='relL=matrix{'+ ', '.join(['{'+', '.join([str(relL[i,j]) for j in range(len(relL.columns()))])+'}\n' for i in range(len(relL.rows()))])+'}'
    #relCm2='relC=matrix{'+ ', '.join(['{'+', '.join([str(relC[i,j]) for j in range(len(relC.columns()))])+'}\n' for i in range(len(relC.rows()))])+'}'
        
    #relCoC=str([list(set(relaxM.groundset())-set(h)) for h in relaxM.hyperplanes()])

    #relpI='relI='+pIdeal(relaxA)

    #### -- this pertains to ideal of non-M-parking functions ###########
        
    nonParking=MParkingFunctions(A)

    #### -- this pertains to ideal of non-Mrel-parking functions ###########
        
    #nonParkingRelax=MParkingFunctions(relaxA)

    #### -- this pertains to ideal of all monomials appearing in
    #### -- cocircuit powers of linear forms ###########

    #mon=columnForms(A)

    

    ############# generate m2 script ############

    with open('out/ParkingTransversal'+setSystem+'.m2', 'w') as archivo:

        archivo.write('daFile = "ParkingTransversal'+setSystem+'" << " " \n')

        decPoly = 'R=QQ[' + ','.join(['x_'+str(i+1) for i in range(rk)]) + ']'
        archivo.write(decPoly+';\n')
            
        
        # -- this pertains to original matroid #####################       
    
        archivo.write(Am2+';\n')

        archivo.write(Lm2+';\n')
        archivo.write(Cm2+';\n')

        archivo.write(pI+';\n')

        archivo.write('T = betti res I;\n')       

        archivo.write('ismono=isMonomialIdeal ideal(mingens I) ;\n')

 

        # -- this pertains to relaxed matroid #####################

    
        #archivo.write(relAm2+';\n')

        #archivo.write(relLm2+';\n')
        #archivo.write(relCm2+';\n')

        #archivo.write(relpI+';\n')
        #archivo.write('relT = betti res relI;\n')

        #archivo.write('relismono=isMonomialIdeal ideal(mingens relI) ;\n')



        # -- this pertains to ideal of non-M-parking functions ###########
        
        archivo.write('nonParkingIdeal='+nonParking+';\n')
        archivo.write('parkingT=betti res nonParkingIdeal;\n')


        # -- this pertains to ideal of non-Mrel-parking functions ###########
        
        #archivo.write('nonParkingIdealRelax='+nonParkingRelax+';\n')
        #archivo.write('parkingTRelax=betti res nonParkingIdealRelax;\n')

        #### -- this pertains to ideal of all monomials appearing in
        #### -- cocircuit powers of linear forms ###########

        #archivo.write('allMon=('+mon+');\n')
        #archivo.write('allMonBetti=betti res allMon;\n')
        #archivo.write('minimalCocircuits=mingens allMon;\n')


        
        #################################################
        # print m2 output to a file #####################
        
        # first original matroid    #####################

        archivo.write('daFile << "-----------------------------------------------------------------" << endl\n')
        archivo.write('daFile << "--originalmatroid------------------------------------------------" << endl\n')

        archivo.write('daFile << "'+setSystem+'" << endl\n')
        archivo.write('daFile << "" << endl\n')      


        archivo.write('daFile << "lines matrix * representation Matrix = cocircuit matrix:"<< endl \n')
        archivo.write('daFile << L <<"*" << A << "="<< C << endl \n')            
        archivo.write('daFile << "" << endl\n')       
    
        archivo.write('daFile << "power ideal:" << endl \n')
        archivo.write('daFile << apply(apply(first entries gens I, f-> factor f), h-> toString h) << endl \n')
        archivo.write('daFile << "" << endl\n')

        archivo.write('daFile << "primal is monomial? " << ismono << endl \n')
        archivo.write('daFile << "" << endl\n')

        #archivo.write('daFile << "power ideal minimal generators:" << endl \n')
        #archivo.write('daFile << toString mingens I << endl \n')
        #archivo.write('daFile << "" << endl\n')

        archivo.write('daFile << "cocircuits:" << endl \n')
        archivo.write('daFile << "' + CoC + '" << endl \n')
        archivo.write('daFile << "" << endl\n')            

        #archivo.write('daFile << "basis aka parking functions:" << endl \n')
        #archivo.write('daFile << toString basis (R/I) << endl \n')
        #archivo.write('daFile << "" << endl\n')                        

        archivo.write('daFile << "Hilbert series:" << reduceHilbert hilbertSeries (R/I) << endl \n')
        archivo.write('daFile << "" << endl\n')

        archivo.write('daFile << "betti table of I" << endl \n')
        archivo.write('daFile << "   " || "" || net T' + '| "    " << endl \n')
        archivo.write('daFile << "" << endl \n')

        
        # -- this pertains to monomial ideal for graphs only #####################

        ##rowForms=','.join(['+'.join(['('+str(r[i])+')*y'+str(i+1) for i in range(num) if r[i]!=0]) for r in A.rows()])
        ##decPoly2='S=QQ['+','.join(['y'+str(j+1) for j in range(num)])+']'
        

        #archivo.write('monoI='+graphPS(g)+';\n')
        #archivo.write('monoT = betti res monoI;\n')
        #archivo.write('nonGParking=monoI/nonParkingIdeal;\n')
        #archivo.write('B=basis nonGParking;\n')
        #archivo.write('minB=mingens nonGParking;\n')

        #archivo.write('daFile << "-----------------------------------------------------------------" << endl\n')
        #archivo.write('daFile << "--graphmonomialideal---------------------------------------------" << endl\n')

        #archivo.write('daFile << "graph monomial ideal:" << endl \n')
        #archivo.write('daFile << apply(first entries gens monoI, h-> toString h) << endl \n')
        #archivo.write('daFile << "" << endl\n')

        #archivo.write('daFile << "basis aka parking functions:" << endl \n')
        #archivo.write('daFile << toString basis (R/monoI) << endl \n')
        #archivo.write('daFile << "" << endl\n')                        

        #archivo.write('daFile << "Hilbert series:" << reduceHilbert hilbertSeries (R/monoI) << endl \n')
        #archivo.write('daFile << "" << endl\n')
    
        #archivo.write('daFile << "betti table of monoI" << endl \n')
        #archivo.write('daFile << "   " || "" || net monoT' + '| "    " << endl \n')
        #archivo.write('daFile << "" << endl \n')

        ##archivo.write(decPoly2+';\n')
        ##archivo.write('IsqFree=ideal('+','.join(['y'+str(j+1)+'^2' for j in range(num)])+');\n')
        ##archivo.write('f=map(S,R,{'+rowForms+'})\n')
        ##archivo.write('cutMonomials=apply(apply(first entries gens monoI, m->f m), p->toString(leadTerm(p%IsqFree)))\n')
        
        ##archivo.write('daFile << "leading terms of monomial expansions:" << endl \n')
        ##archivo.write('daFile << cutMonomials << endl \n')
        ##archivo.write('daFile << "" << endl\n')

        #archivo.write('daFile << "PS monomial ideal contains nonParkingIdeal?:" << isSubset(nonParkingIdeal,monoI) << endl \n')
        #archivo.write('daFile << "" << endl\n')
        

        
        #### -- this pertains to ideal of all monomials appearing in
        #### -- cocircuit powers of linear forms ###########        

        #archivo.write('daFile << "-----------------------------------------------------------------" << endl\n')
        #archivo.write('daFile << "--ideal of monomials in cocircuit products of linear forms---------" << endl\n')

        #archivo.write('daFile << "that monomial ideal:" << endl \n')
        #archivo.write('daFile << apply(first entries minimalCocircuits, h-> toString h) << endl \n')
        #archivo.write('daFile << "" << endl\n')


        #archivo.write('daFile << "Hilbert series:" << reduceHilbert hilbertSeries (R/allMon) << endl \n')
        #archivo.write('daFile << "" << endl\n')
    
        #archivo.write('daFile << "betti table of that ideal" << endl \n')
        #archivo.write('daFile << "   " || "" || net allMonBetti' + '| "    " << endl \n')
        #archivo.write('daFile << "" << endl \n')

        
        
        # then relaxed matroid #####################    

        #archivo.write('daFile << "-----------------------------------------------------------------" << endl\n')
        #archivo.write('daFile << "--relaxedmatroid-------------------------------------------------" << endl\n')

        #archivo.write('daFile << "lines matrix * representation Matrix = cocircuit matrix:"<< endl \n')
        #archivo.write('daFile << relL <<"*" << relA << "="<< relC << endl \n')            
        #archivo.write('daFile << "" << endl\n')       
    
        #archivo.write('daFile << "power ideal:" << endl \n')
        #archivo.write('daFile << apply(apply(first entries gens relI, f-> factor f), h-> toString h) << endl \n')
        #archivo.write('daFile << "" << endl\n')

        #archivo.write('daFile << "primal is monomial? " << relismono << endl \n')
        #archivo.write('daFile << "" << endl\n')

        #archivo.write('daFile << "power ideal minimal generators:" << endl \n')
        #archivo.write('daFile << apply(first entries mingens relI, h-> toString h) << endl \n')
        #archivo.write('daFile << "" << endl\n')

        #archivo.write('daFile << "cocircuits:" << endl \n')
        #archivo.write('daFile << "' + relCoC + '" << endl \n')
        #archivo.write('daFile << "" << endl\n')            

        #archivo.write('daFile << "basis aka parking functions:" << endl \n')
        #archivo.write('daFile << toString basis (R/relI) << endl \n')
        #archivo.write('daFile << "" << endl\n')                        

        #archivo.write('daFile << "Hilbert series:" << reduceHilbert hilbertSeries (R/relI) << endl \n')
        #archivo.write('daFile << "" << endl\n')
    


        #archivo.write('daFile << "betti table of relI" << endl \n')
        #archivo.write('daFile << "   " || "" || net relT' + '| "    " << endl \n')
        #archivo.write('daFile << "" << endl \n')

        # -- ideal generated by non-M-parking functions #####################
        
        archivo.write('daFile << "-----------------------------------------------------------------" << endl\n')
        archivo.write('daFile << "--nonMParkingFunctionIdeal---------------------------------------" << endl\n')

        archivo.write('daFile << "nonParkingIdeal minimal generators:" << endl \n')
        archivo.write('daFile <<  apply(first entries mingens nonParkingIdeal, m-> toString m) << endl \n')
        archivo.write('daFile << "" << endl\n')

#        archivo.write('daFile << "M parking functions:" << endl \n')
#        archivo.write('daFile << toString basis (R/nonParkingIdeal) << endl \n')
#        archivo.write('daFile << "" << endl\n')                        

        archivo.write('daFile << "Hilbert series:" << reduceHilbert hilbertSeries (R/nonParkingIdeal) << endl \n')
        archivo.write('daFile << "" << endl\n')

  
        archivo.write('daFile << "betti table of nonParkingIdeal" << endl \n')
        archivo.write('daFile << "   " || "" || net parkingT' + '| "    " << endl \n')
        archivo.write('daFile << "" << endl \n')

        # -- ideal generated by non-Mrel-parking functions #####################
        
        #archivo.write('daFile << "-----------------------------------------------------------------" << endl\n')
        #archivo.write('daFile << "--nonMParkingFunctionIdealRelax----------------------------------" << endl\n')
        #archivo.write('daFile << "--this should correspond exactly to relaxed power ideal----------" << endl\n')

        #archivo.write('daFile << "nonParkingIdealRelaxed minimal generators:" << endl \n')
        #archivo.write('daFile <<  apply(first entries mingens nonParkingIdealRelax, m-> toString m) << endl \n')
        #archivo.write('daFile << "" << endl\n')

#        archivo.write('daFile << "M parking functions:" << endl \n')
#        archivo.write('daFile << toString basis (R/nonParkingIdeal) << endl \n')
#        archivo.write('daFile << "" << endl\n')                        

        #archivo.write('daFile << "Hilbert series:" << reduceHilbert hilbertSeries (R/nonParkingIdealRelax) << endl \n')
        #archivo.write('daFile << "" << endl\n')

  
        #archivo.write('daFile << "betti table of nonParkingIdealRelax" << endl \n')
        #archivo.write('daFile << "   " || "" || net parkingTRelax' + '| "    " << endl \n')
        #archivo.write('daFile << "" << endl \n')

        ### comparisons

        archivo.write('daFile << "NonParkingIdeal equals Original?:" << nonParkingIdeal==I << endl \n')
        archivo.write('daFile << "" << endl\n')

        #archivo.write('daFile << "NonParkingIdeal equals Relaxed Power ideal?:" << nonParkingIdeal==relI << endl \n')
        #archivo.write('daFile << "" << endl\n')

        #archivo.write('daFile << "NonParkingIdeal equals NonParkingIdealRelax?:" << nonParkingIdeal==nonParkingIdealRelax<< endl \n')
        #archivo.write('daFile << "" << endl\n')


        # this also pertains only to graph power ideals!!
        
        #archivo.write('daFile << "PS power ideal contains nonParkingIdeal?:" << isSubset(nonParkingIdeal,I) << endl \n')
        #archivo.write('daFile << "" << endl\n')

        #archivo.write('daFile << "M parking functions that are not G-parking:" << endl \n')
        #archivo.write('daFile << toString super B << endl \n')
        #archivo.write('daFile << "Minimal ones:" << endl \n')
        #archivo.write('daFile << toString super minB << endl \n')
        #archivo.write('daFile << "" << endl\n') 

                    
        archivo.write('daFile << close \n')


def testIntersection(A):
    # receives a matrix A and checks whether the
    # intersection of M(A) with the transversal
    # relaxation of M(A) is a matroid

    M=Matroid(A)

    setSystem=[[i for i in range(len(r)) if r[i]!=0] for r in A.rows()]

    relaxA=transM(setSystem)
    relaxM=Matroid(relaxA)

    print len(relaxM.bases()), len(M.bases())
    commonBases=[b for b in M.bases() if b in relaxM.bases()]
    print len(commonBases)#, commonBases

    MInt=Matroid(bases=commonBases)
    return MInt.is_valid()

def MParkingFunctions(A):
    # receives a full-rank matrix A and returns a list
    # of the M-parking functions associated to M=M(A)
    # where a parking function is a sequence of nonnegative
    # integers p such that the transversal relaxation of M
    # has a p-transversal that is co-independent

    d=A.rank()
    n=len(A.columns())
    
    

    M=Matroid(A)

    E=M.groundset()

    setSystem=[[i for i in range(len(r)) if r[i]!=0] for r in A.rows()]

    projections=[]

    for J in Subsets(range(d)):
        if len(J)>0:
            AJ=[]
            for j in J:
                new=[i for i in setSystem[j] if i not in AJ]
                AJ=AJ+new
            projections.append([list(J),sorted(AJ)])

            
    Mon=IntegerVectors(n-d+1,d+1) # this choice of n-d+1 the minimum that accounts for possible cocircuits!

    #### test
    for JAJ in projections: print JAJ[0], M.corank(JAJ[1]), len(JAJ[1])-len(JAJ[0])
    
    #### end of test

    parkingList=[]

    # the following is a test to understand the difference with relaxed version

    relaxA=transM(setSystem)
    relaxM=Matroid(M)

    for p in Mon:
        for S in projections:
            if M.corank(S[1])<sum([p[i+1] for i in S[0]]): break

        else: parkingList.append(p)

    #nonParking=[m for m in Mon if m not in parkingList]
    
    nonParking='ideal('+','.join(['*'.join(['x_'+str(i)+'^'+str(m[i]) for i in range(1,d+1) if m[i]!=0]) for m in Mon if m not in parkingList])+')'
    
    
    #print 'parkings', len(parkingList), parkingList
    return nonParking

    
def rowForms(A):
    # receives a d times n matrix a and produces d linear forms
    # labeled x1..xd in varialbes y1..yn where jth coefficient
    # of ith form is Aij

    d=len(A.rows())
    n=len(A.columns())
    M=Matroid(A)

    decPoly2='S=QQ['+','.join(['y'+str(j+1) for j in range(n)])+']'
    
    squares='Isquares=ideal('+','.join(['y'+str(j+1)+'^2' for j in range(n)])+')'
    cocircuits='coIdeal=ideal('+','.join(['*'.join(['y'+str(i+1) for i in list(C)]) for C in M.cocircuits()])+')'
    RsqFree='R=S/(Isquares+coIdeal)'
    rowForms=','.join(['x'+str(i+1)+'='+'+'.join(['('+str(A[i,j])+')*y'+str(j+1) for j in range(n) if A[i,j]!=0]) for i in range(d)])
    

    return decPoly2+'; '+squares+'; '+cocircuits+';'+RsqFree+'; '+rowForms+'; '

            
def columnForms(A):
    # receives d times n matrix A and produces first the
    # linear forms defined by columns of A, then the products
    # of forms labeled by elements of cocircuits, then extracts
    # monomials from these products to use as generators for
    # a monomial ideal

    d=len(A.rows())
    n=len(A.columns())

    M=Matroid(A)

    columnForms=['+'.join(['('+str(A[i,j])+')*x'+str(i+1) for i in range(d) if A[i,j]!=0]) for j in range(n)]

    monomialsInProductForms='+'.join(['ideal(monomials('+'*'.join(['('+columnForms[j]+')' for j in sorted(list(C))])+'))\n' for C in M.cocircuits()])
    


    return monomialsInProductForms

def Polymatroid(S):
    # receives a set system S and computes the inequalities
    # of the polymatroid defined by the submodular function
    # f: I\mapsto rankdualtransversalmatroid(A(I))
    # returns polymake input in a file

    A=transM(S)
    
    d=len(A.rows())
    n=len(A.columns())

    M=Matroid(A)

    
    inequalities=[]
    info=[]

    for J in Subsets(range(d)):
        if len(J)>0:
            AJ=[]
            for j in J:
                new=[i for i in S[j] if i not in AJ]
                AJ=AJ+new
            AJ.sort()
            #info.append('J='+str(list(J))+', rperp(AJ)='+str(M.corank(AJ))+', |AJ|-|J|+1='+str(len(AJ)-len(J)+1))
            info.append('J='+str(list(J))+', rperp(AJ)='+str(M.corank(AJ))+', |AJ|='+str(len(AJ)))
                
            ineq='['+str(M.corank(AJ))+','+','.join(['-1' if l in J else '0' for l in range(d)])+']'
            #ineq='['+str(len(AJ)-len(J)+1)+','+','.join(['-1' if l in J else '0' for l in range(d)])+']' # large
            
            inequalities.append(ineq)

            
    printInfo=',\n'.join([i for i in info])
            
    pos=['['+'0,'+','.join(['1' if j==i else '0' for j in range(d)])+']' for i in range(d)]
    
    inequalities=inequalities+pos
    
    toPolymake='$A=new Matrix<Rational>(['+',\n'.join([J for J in inequalities])+'])'

    # now also compute the dual independent set polytope to test whether its bases are in bijection
    # with integer points in polymatroid
    
    inequalities2=[]
    info2=[]
    for T in Subsets(range(n)):
        ineq2='['+str(M.rank(T))+','+','.join(['-1' if l in T else '0' for l in range(n)])+']'
        inequalities2.append(ineq2)
        info2.append(str(list(T))+','+str(M.rank(T)))

    printInfo2=',\n'.join([i for i in info2])
        
    pos2=['['+'0,'+','.join(['1' if j==i else '0' for j in range(n)])+']' for i in range(n)]
    
    inequalities2=inequalities2+pos2+['['+str(-M.rank())+','+','.join(['1' for l in range(n)])+']']
    
    toPolymake2='$B=new Matrix<Rational>(['+',\n'.join([T for T in inequalities2])+'])'

    setSystem='-'.join([''.join([str(i) for i in I]) for I in S])
    
    with open('out/polymatroid'+setSystem, 'w') as archivo:
        archivo.write(toPolymake+';\n')
        archivo.write('$P= new Polytope<Rational>(INEQUALITIES=>$A);\n')
        archivo.write('print $P->FACETS;\n')
        archivo.write('print $P->N_LATTICE_POINTS;\n')
        archivo.write(printInfo+'\n')

        archivo.write(toPolymake2+';\n')
        archivo.write('$Q= new Polytope<Rational>(INEQUALITIES=>$B);\n')
        archivo.write('print $Q->FACETS;\n')
        archivo.write(printInfo2+'\n')

def writeLines(sys):
    # receives a set system sys as input. writes symbolically
    # all the lines corresponding to a standard representation
    # of the transversal matroid defined by sys

    r=len(sys)

    setSystem='-'.join([''.join([str(i) for i in I]) for I in sys])

    groundset=[]
    
    for s in sys:
        for i in s:
            if i not in groundset: groundset.append(i)
    groundset.sort()

    signos=['-' if j%2==0 else '+' for j in range(r-1)]

    lines=[]
    
    for mu in Subsets(groundset,r-1):
        
        dets=[]
        
        for l in range(r):
            
            J=list(Set(range(r)).difference(set([l])))
            
            coeffs='\\begin{vmatrix}'+' \\\\ '.join([' & '.join(['a_{'+str(j)+str(t)+'}' if t in sys[j] else '0' for t in mu]) for j in J])+'\\end{vmatrix}'+'x_{'+str(l)+'}'

            dets.append(coeffs)

        linearForm=[None]*(2*r-1)
        linearForm[::2]=dets
        linearForm[1::2]=signos
        Q=''.join([w for w in linearForm])
        lines.append([''.join([str(i) for i in mu]),Q])

        
    with open('out/symbolicLines'+setSystem+'.tex', 'w') as archivo:

        archivo.write('\\documentclass[a4paper]{article}\n')
        archivo.write('\\usepackage{amsmath}\n')
        archivo.write('\\usepackage[left=2cm, right=2cm,textheight=26cm]{geometry}\n')
        archivo.write('\\setlength{\\headsep}{1cm}\n')
        archivo.write('\\begin{document}\n')
        archivo.write('$S=\\{'+','.join(['\\{'+','.join([str(i) for i in s])+'\\}' for s in sys])+'\\}$'+'\n')
        archivo.write('\\footnotesize\n')

        archivo.write('\n'.join(['\\begin{align*}\n'+K[0]+'&'+K[1]+'\\end{align*}\n' for K in lines]))

        archivo.write('\\end{document}\n')
